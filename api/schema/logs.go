package schema

// LagoonLog is used to sendToLagoonLogs messaging queue
// this is general logging information
type LagoonLog struct {
	Severity string         `json:"severity,omitempty"`
	Project  string         `json:"project,omitempty"`
	UUID     string         `json:"uuid,omitempty"`
	Event    string         `json:"event,omitempty"`
	Meta     *LagoonLogMeta `json:"meta,omitempty"`
	Message  string         `json:"message,omitempty"`
}

type LagoonMessage struct {
	Type      string         `json:"type,omitempty"`
	Namespace string         `json:"namespace,omitempty"`
	Meta      *LagoonLogMeta `json:"meta,omitempty"`
}

// LagoonLogMeta is the metadata that is used by logging in Lagoon.
type LagoonLogMeta struct {
	BranchName    string          `json:"branchName,omitempty"`
	BuildName     string          `json:"buildName,omitempty"`
	BuildStatus   string          `json:"buildStatus,omitempty"`
	BuildPhase    string          `json:"buildPhase,omitempty"` // legacy but still used until `buildStatus` is more available
	BuildStep     string          `json:"buildStep,omitempty"`
	EndTime       string          `json:"endTime,omitempty"`
	Environment   string          `json:"environment,omitempty"`
	EnvironmentID *uint           `json:"environmentId,omitempty"`
	JobName       string          `json:"jobName,omitempty"`   // used by tasks/jobs
	JobStatus     string          `json:"jobStatus,omitempty"` // used by tasks/jobs
	JobStep       string          `json:"jobStep,omitempty"`   // used by tasks/jobs
	LogLink       string          `json:"logLink,omitempty"`
	Project       string          `json:"project,omitempty"`
	ProjectID     *uint           `json:"projectId,omitempty"`
	ProjectName   string          `json:"projectName,omitempty"`
	RemoteID      string          `json:"remoteId,omitempty"`
	Route         string          `json:"route,omitempty"`
	Routes        []string        `json:"routes,omitempty"`
	StartTime     string          `json:"startTime,omitempty"`
	Services      []string        `json:"services,omitempty"`
	Task          *LagoonTaskInfo `json:"task,omitempty"`
	Key           string          `json:"key,omitempty"`
	AdvancedData  string          `json:"advancedData,omitempty"`
	Cluster       string          `json:"clusterName,omitempty"`
}

// LagoonTaskInfo defines what a task can use to communicate with Lagoon via SSH/API.
type LagoonTaskInfo struct {
	ID       string `json:"id"` // should be int, but the api sends it as a string :\
	Name     string `json:"name,omitempty"`
	TaskName string `json:"taskName,omitempty"`
	Service  string `json:"service,omitempty"`
	Command  string `json:"command,omitempty"`
	SSHHost  string `json:"sshHost,omitempty"`
	SSHPort  string `json:"sshPort,omitempty"`
	APIHost  string `json:"apiHost,omitempty"`
}

func (in *LagoonLog) DeepCopyInto(out *LagoonLog) {
	*out = *in
	if in.Meta != nil {
		in, out := &in.Meta, &out.Meta
		*out = new(LagoonLogMeta)
		(*in).DeepCopyInto(*out)
	}
}

func (in *LagoonLog) DeepCopy() *LagoonLog {
	if in == nil {
		return nil
	}
	out := new(LagoonLog)
	in.DeepCopyInto(out)
	return out
}

func (in *LagoonLogMeta) DeepCopy() *LagoonLogMeta {
	if in == nil {
		return nil
	}
	out := new(LagoonLogMeta)
	in.DeepCopyInto(out)
	return out
}

func (in *LagoonLogMeta) DeepCopyInto(out *LagoonLogMeta) {
	*out = *in
	if in.EnvironmentID != nil {
		in, out := &in.EnvironmentID, &out.EnvironmentID
		*out = new(uint)
		**out = **in
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(uint)
		**out = **in
	}
	if in.Routes != nil {
		in, out := &in.Routes, &out.Routes
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Services != nil {
		in, out := &in.Services, &out.Services
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.Task != nil {
		in, out := &in.Task, &out.Task
		*out = new(LagoonTaskInfo)
		**out = **in
	}
}

func (in *LagoonMessage) DeepCopyInto(out *LagoonMessage) {
	*out = *in
	if in.Meta != nil {
		in, out := &in.Meta, &out.Meta
		*out = new(LagoonLogMeta)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LagoonMessage.
func (in *LagoonMessage) DeepCopy() *LagoonMessage {
	if in == nil {
		return nil
	}
	out := new(LagoonMessage)
	in.DeepCopyInto(out)
	return out
}
